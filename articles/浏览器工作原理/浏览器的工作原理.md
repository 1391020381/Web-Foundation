*  [从浏览器多进程到JS单线程,JS运行机制最全面的一次梳理](https://juejin.im/post/5a6547d0f265da3e283a1df7)
* [这一次，彻底弄懂 JavaScript 执行机制](https://juejin.im/post/59e85eebf265da430d571f89)
* [浏览器的工作原理：新式网络浏览器幕后揭秘](https://www.html5rocks.com/zh/tutorials/internals/howbrowserswork/)
* [并发模型与事件循环](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/EventLoop)
* [宏任务和微任务](https://jakearchibald.com/2015/tasks-microtasks-queues-and-schedules/)
1. 异步过程的构成要素
* 主线程发起一个异步请求,相应的工作线程接收请求并告知主线程已收到(异步函数返回);主线程可以继续执行后面的代码,同时工作线程执行异步任务；工作线程完成工作后,告知主线程；主线程收到通知后,执行一定的动作(调用回调函数)。
2. 消息队列和事件循环
    * 工作线程将消息放到消息队列,主线程通过事件循环过程出取消息。
    * 消息队列：就是一个先进先出的队列,它里面存放着各种消息
    * 事件循环：事件循环是指主线程重复从消息队列中取消息、执行的过程。
    * 主线程只会做一件事情,就是从消息队列里面取消息、执行消息、再取消息、再执行。当消息队列为空时,就会等待直到消息队列变成非空。而且主线程只有在将当前的消息执行完成后,才会去取下一个消息。这种机制就叫做事件机制,取一个消息并执行的过程叫做一次循环。

![](https://raw.githubusercontent.com/1391020381/Web-Foundation/master/articles/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/img/%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF.png)

 * js引擎存在 monitoring process进程,会持续不断的检查主线程执行栈是否为空,一旦为空，就会去Event Queue那里检查是否有等待被调用的函数。
3. setTimeout    
    * 经过指定时间后,把要执行的任务加入到Event Queue中,又因为是单线程任务要一个一个执行,如果前面的任务需要的时间太久,那么只能等着,导致真正的延迟时间远远大于3秒
    * setTimeout(fn,0)的含义是,指定某个任务在主线程最早可得的空闲时间执行,意思就是不用等多少秒了,只要主线程执行栈内的同步任务全部执行完成,栈为空就马上执行。
    * 即便主线程为空,0毫秒实际上也是达不到的。根据HTML的标准,最低是4毫秒。
4. setInterval
    * setInterval会每隔指定的时间将注册的函数置入Event  Queue,如果前面的任务耗时太久,那么同样需要等待。
    * setInterval(fn,ms)来说,我们已经知道不是每过ms秒会执行一次fn，而是每过ms秒,会有fn进入Event Queue。一旦setInterval的函调函数fn执行时间超过了延迟时间ms,那么就完全看不出来时间间隔了。
5.  Promise与process.nextTick(callback)     
*  macro-task(宏任务) :包括整体代码 script  setTimeout    setInterval
* micro-task (微任务): Promise  process.nextTick  
* 不同类型的任务会进入对应的Event Queue 比如 setTimeout和setInterval会进入相同的Event Queue
* `事件循环的顺序,决定js代码的执行顺序。进入整体代码(宏任务)后,开始第一次循环。接着执行所有的微任务。然后再次从宏任务开始,找到其中一个任务队列执行完毕,再执行所有的微任务。`

![](https://raw.githubusercontent.com/1391020381/Web-Foundation/master/articles/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/img/%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF%EF%BC%8C%E5%AE%8F%E4%BB%BB%E5%8A%A1%EF%BC%8C%E5%BE%AE%E4%BB%BB%E5%8A%A1%E7%9A%84%E5%85%B3%E7%B3%BB.png)


6. 总结
* js的异步  使用同步的方法模仿
* 事件循环Event Loop   js实现异步的一种方法  也就是js执行机制
* js的执行和运行  执行和运行有很大的区别，javascript在不同的环境下，比如node，浏览器，Ringo等等，执行方式是不同的。而运行大多指javascript解析引擎，是统一的。
* setImmediate
 *  javascript是一门单线程语言   Event Loop是javascript的执行机制
# 从浏览器进程,再到浏览器内核运行再到JS引擎单线程,再到JS事件循环机制。
 ## 浏览器多进程
 * 进程是cpu资源分配的最小单位(系统会给它分配内存，是能拥有资源和独立运行的最小单位)
 * 线程是cpu调度的最小单位(线程是建立在进程的基础上的一次程序运行单位,一个进程中可以有多个线程)
 * tips
 * 不同进程之间也可以通信,不过代价较大
 * 现在，一般通用的叫法:单线程与多线程,都是指在一个进程内的单和多。(所以核心还是得属于一个进程才行。) 
* 浏览器是多进程的
* 浏览器之所以能够运行,时因为系统给它的进程分配了资源(cpu、内存)
* 简单点理解、每打开一个Tab页,就相当于创建一个独立的浏览器进程。
* 浏览器应该有自己的优化机制,有时候打开多个tab页后,可以在Chrome任务管理器中看到,有些进程被合并了(所以每一个Tab标签对应一个进程并不一定是绝对的。)
1. Browser进程：浏览器的主进程(负责协调、主控)，只有一个。作用有
* 负责浏览器界面显示,与用户交互。如前进，后退等。
* 负责各个页面的管理、创建和销毁其他进程
* 将Renderer进程得到内存中的Bitmap,绘制到用户界面上
* 网络资源的管理、下载等。
2. 第三方插件进程：每种类型的插件对应一个进程,仅当使用该插件时才创建
3. GPU进程：最多一个用于3D绘制等
4.  浏览器渲染进程(浏览器内核) (Renderer进程,内部是多线程的):默认每个Tab页面一个进程,互不影响。
* 页面渲染、脚本执行、事件处理等
* 强化记忆：在浏览器中打开一个网页相当于新起来了一个进程(进程内有自己的多线程)
* 另外，可以通过Chrome的更多工具 -> 任务管理器自行验证
## 浏览器多进程的优势
* 避免单个page crash影响整个浏览器
* 避免第三方插件crash影响整个浏览器
* 方便使用沙盒模型隔离插件等进程,提高浏览器稳定性
* 简单理解：如果浏览器是单进程,那么某个Tab页崩溃了,就影响了整个浏览器，体验有多差。同理如果是单进程,插件崩溃了也会影响整个浏览器。而且多进程还有其他的诸多优势。