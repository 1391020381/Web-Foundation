# [从输入URL到页面加载的过程？如何由一道题完善自己的前端知识体系！从输入URL到页面加载的过程？如何由一道题完善自己的前端知识体系！](http://www.dailichun.com/2018/03/12/whenyouenteraurl.html)
# 大纲
1. 对知识的体系进行一次预评级
2. 为什么说知识体系如此重要?
3. 梳理主干流程
4. 从浏览器接受URL到开启网络请求线程
    * 多线程的浏览器
    * 多线程的浏览器内核
    * 解析URL
    * 网络请求都是单独的线程
    * 更多
5. 开启网络线程到发出一个完整的http请求
    * DNS查询得到IP
    * tcp/ip请求
    * 五层因特网协议栈
6. 从服务器接受到请求到对应后台接受到请求
    * 负载均衡
    * 后台的处理
7.  后台和前台的http交互
    * http报文结构
    * cookie以及优化
    * gzip压缩
    * 长连接与短连接
    * http2.0
    * https
 8. 单独拎出来的缓存问题,http的缓存
    * 强缓存与弱缓存
    * 缓存头部简述
    * 头部的区别
9. 解析页面流程
    * 流程简述
    * HTML解析,构建DOM
    * 生成CSS规则
    * 构建渲染树
    * 渲染
    * 简单层与复合层
    * Chrome中的调式
    * 资源外链的下载
    * loaded和documentLoaded
10. CSS的可视化格式模型
    * 包含块(Containing Block)
    * 控制框(Controlling Box)
    * BFC(Block Formatting Context)
    * IFC(Inline Formatting Context)
    * 其他
 11. JS引擎解析过程
    * JS的解释阶段
    * JS的预处理阶段
    * JS的执行阶段
    * 回收机制
 12. 其他
 13. 总结      
 # 对知识体系进行一次预评估
 ## level3
 * 首先略去那些键盘输入、和操作系统交互、以及屏幕显示原理、网卡等硬件交互之类的(前端向中,很多硬件原理暂时略去)
 * 对浏览器模型有整体概念,知道浏览器是多进程的,浏览器内核是多线程的,清楚进程与线程之间的区别,以及输入URL会开一个新的网络线程。
 * 对从开启网络线程到发出一个完整的http请求中间的过程有所了解(如dns查询、tcp/ip连接、五层英特网协议栈等等,以及一些优化方案,如 dns-prefetch)
 * 对从服务器接受到请求到对应后台接受到请求由一定了解(如负载均衡、安全拦截以及后台代码处理等)
 * 对后台和前台的HTTP交互熟悉(包括http报文结构、场景头部、cookie、跨域、web安全、http缓存、http2.0、https等)
 * 对浏览器接受到http数据包后的解析流程熟悉(包括解析html、词法分析然后解析成dom树、解析css生成css规则树、合并成render树、然后layout、painting渲染、里面可能包括复合图层的合成、GPU绘制、外链处理、加载顺序等)
 * 对JS引擎解析过程熟悉(包括js的解释、预处理、执行上下文、VO、作用域链、this、回收机制等)
## level4
[从输入 URL 到页面加载完成的过程中都发生了什么事情？](http://fex.baidu.com/blog/2014/05/what-happen/)
# 知识体系的重要性
## getComputedStyle
* window.getComputedStyle(elem,null).getPropertyValue('height')可能是值为100px,而且,就算是css上写的是inherit，getComputedStyle也会把它最终计算出来的。不过注意,如果元素的背景透明,那么getComputedStyle获取出来的就是透明的这个背景(因为透明本身也是有效的),而不会是父节点的背景。所以它不一定是最终显示的颜色。
* getComputedStyle会获取当前元素所有最终使用的CSS属性值,window和document.defaultView等价
* getComputedStyle会引起回流,因为它需要获取祖先节点的一些信息进行计算(譬如宽高等),所以用的时候慎用,回流会引起性能问题。然后合适的会话将引导回流、重绘、浏览器渲染原理等等。offsetXXX  scrollXXX  clientXXX  currentStyle等等。
## visibility: hidden和display: none的区别
* 普通回答，一个隐藏，但占据位置，一个隐藏，不占据位置

* 进一步，display由于隐藏后不占据位置，所以造成了dom树的改变，会引发回流，代价较大

* 再进一步，当一个页面某个元素经常需要切换display时如何优化，一般会用复合层优化，或者要求低一点用absolute让其脱离普通文档流也行。然后可以将话题引到普通文档流，absolute文档流，复合图层的区别，

* 再进一步可以描述下浏览器渲染原理以及复合图层和普通图层的绘制区别（复合图层单独分配资源，独立绘制，性能提升，但是不能过多，还有隐式合成等等）
* [详谈层合成(composite)](https://juejin.im/entry/59dc9aedf265da43200232f9)
# 前端向知识的重点
* 核心知识,必须掌握的,也是最基础的,譬如浏览器模型,渲染原理、JS解析过程、JS运行机制等，作为骨架来承载知识体系。
* 重点知识,往往每一块都是一个知识点,而且这些知识点都很重要,譬如http相关、web安全相关、跨域处理等等。
* 拓展知识,这一块可能更多的是了解,稍微实践过,但是认识上可能没有上面那个深刻,譬如五层因特网协议栈,hybrid模式、
移动原生开发、后台开发等等(还要看不同领域。)
# 梳理主干流程
1. 从浏览器接受url到开启网络请求线程(这一部分可以展开浏览器的机制以及进程与线程之间的关系)
2. 开启网络线程到发出一个完整的http请求(这一部分涉及到dns查询、tcp/ip请求、五层因特网协议等知识)
3. 从服务器接受到请求到对应后台就收到请求(这一部分可能涉及到负载均衡、安全拦截以及后台内部处理等等)
4. 后台和前台的http交互(这一部分包括http头部、响应码、报文结构、cookie等知识,还可以提下静态资源的cookie优化。以及编码解密,如gzip压缩等)
5. 单独拎出来的缓存问题,http的缓存(这部分包括http缓存头部,etag,catch-control等)
6. 浏览器接受到http数据包后的解析流程(解析html-词法解析然后解析成dom树、解析css生成css规则树、合并成render树,然后layout、painting渲染、复合图层的合成、GPU绘制、外链资源的处理、loaded和domcontentloaded等)
7. css的可视化格式模型(元素的渲染规则,如包含块、控制框、BFC、IFC等概念)
8. JS引擎解析过程(js的解释阶段、预处理阶段、执行阶段生成执行上下文,VO,作用域链、回收机制等等。)
9. 其他(可以拓展不同的只是模块,如跨域、web安全、hybrid模式等等内容)
# 从浏览器接收url到开启网络请求线程
* 浏览器进程/线程模型    JS的运行机制
## 多进程的浏览器
* 浏览器是多进程的,有一个主控进程,以及每一个tab页面都会新开一个进程(某些情况下多个tab会合并进程)
* 进程可能包含主控进程、插件进程、GPU、tab页(浏览器内核)等等
    * Browser进程：浏览器的主进程(负责协调、主控)，只有一个
    * 第三方插件进程：每种类型的插件对应一个进程,仅当使用该插件时才创建。
    * GPU进程：最多一个,用于3D绘制
    * 浏览器渲染进程(内核):默认每个tab页面一个进程,互不影响、控制页面渲染、脚本执行、事件处理等(有时候会优化,如多个空白tab会合并成一个进程)
### 多进程的浏览器内核
* 每一个tab页面可以看做是浏览器内核进程,然后这个进程是多线程的
    * GUI线程
    * JS线程
    * 事件触发线程
    * 定时器线程
    * 网络请求线程    

    ![](https://raw.githubusercontent.com/1391020381/Web-Foundation/master/articles/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/img/browser_inner_thread.png)

### 解析URL
* 输入URL后，会进行解析(url的本质就是统一资源定位符)
 * URL一般包括几大部分：
     * protocol 协议头 譬如http ftp
     * host  主机域名或ip地址
     * port  端口号
     * path  目录路径
     * query 即查询参数
     * fragment 即 # 后的hash值 一般用来定位到某个位置
### 网络请求都是单独的线程
* 每次网络请求时都需要开辟单独的线程进行,譬如如果URL解析到http协议,就会新建一个网络线程去处理资源下载。
* 因此浏览器会根据解析出的协议,开辟一个网络线程,前往请求资源(这里,暂时理解为是浏览器内核开辟的)
### 更多

[从浏览器多进程到JS单线程，JS运行机制最全面的一次梳理](https://segmentfault.com/a/1190000012925872)     

### 开启网络线程到发出一个完整的HTTP请求
#### DNS查询得到IP
* 如果输入的是域名,需要进行dns解析成ip,大致流程
    * 如果浏览器有缓存,直接使用浏览器缓存,否则使用本机缓存,再没有的话就是用host
    * 如果本地没有，就向DNS域名服务器查选(当然,中间可能还会经过路由,也有缓存等),查询到对应的IP
    * 注意,域名查询时有可能是经过了CDN调度器的(如果有cnd储存功能的话)
    * 而且,需要知道dns解析是很耗时的,因此如果杰行行行域名过多,会让首屏加载变得过慢,可以考虑dns-prefetch优化
 ### tcp/ip请求
 * http的本质就是TCP/IP请求
    * 三次握手的步骤
    * 四次挥手的步骤 (待到断开连接时,需要进行四次挥手,因为是全双工的,所以需要四次挥手)
       * 主动方：我已经关闭了向你那边的主动通道了，只能被动接收了
       * 被动方：收到通道关闭的信息
       * 被动方：那我也告诉你，我这边向你的主动通道也关闭了
        * 主动方：最后收到数据，之后双方无法通信
### tcp/ip的并发限制
* 浏览器对同一个域名下的并发的tcp连接是有限制的(2-10个不等)。
* 在HTTP1.0往往一个资源下载就需要对应一个tcp/ip请求。
### get和post的区别
* get和post虽然本质都是tcp/ip，但是两者除了在http层面外,在tcp/ip层面也有区别
* get会产生一个tcp数据包，post两个
    * get请求时,浏览器会把headers和data一起发送出去,服务器响应200(返回数据)
    * post请求时,浏览器先发送headers,服务器响应100 continue ,浏览器再发送data,服务器响应200(返回数据)。
 * 这里的区别是 specification(规范)层面,而不是implementation(对规范的实现)   
 ## 五层因特网协议栈
* 其实这个概念挺难记全的,记不全没关系,但是要有一个整体概念
* 其实就是一个概念:从客户端发出http请求到服务器接受,中间会进过一系列的流程。
* 从应用层的发送http请求,到传输层通过三次握手建立tcp/ip连接,再到网络层的ip寻址,再到数据链路层的封装成帧,最后到物理层的利用物理介质传输。
* 服务端的接受就是反过来的步骤
* 五层因特网协议栈其实就是:
    * 应用层(dns http)  dns解析成IP并发送http请求
    * 传输层(tcp udp) 建立tcp连接(三次握手)
    * 网络层(IP   ARP) IP 寻址
    * 数据链路层(PPP) 封装成帧
    * 物理层(利用物理介质传输比特流) 物理传输  (然后传输的时候通过双绞线,电磁波等各种介质)
    * 其实也有一个完整的OSI七层框架,与之相比,多了会话层、表示层
    * OSI七层框架 ： 物理层、数据链路层  网络层  传输层、 会话层、 表示层、应用层
    * 表示层:主要处理两个通信系统中交换信息的表示方式,包括数据格式交换,数据加密与解密,数据压缩与终端类型转换等
    * 会话层 ：它具体管理不同用户和进程之间的对话,如控制登录和注销过程
