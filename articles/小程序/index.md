* [深入理解小程序](https://github.com/godbasin/godbasin.github.io#%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E5%B0%8F%E7%A8%8B%E5%BA%8F)
* 逻辑层:创建一个单独线程去执行 javaScript,在这个环境下执行的都是有关小程序业务逻辑的代码。
* 渲染层: 界面渲染相关的任务全都在 WebView线程里执行,通过逻辑层代码控制渲染哪些界面。一个小程序存在多个界面,所以渲染层存在多个WebView线程。
* 逻辑层和渲染层的通信会由 Native(微信客户端) 做中转,逻辑层发送网络请求也经由Native转发。

## 双线程通信
1. 在渲染层把WXML转化成对应的JS对象
2. 在逻辑层发生数据变更的时候,通过宿主环境提供的setData方法把数据从 逻辑层传递到Native,在转发到渲染层。
3. 经过对比前后差异,把差异应用到原生的DOM树上,更新界面。

## 小程序的基础库
* 小程序的基础库时javaScript编写的,它可以被注入到渲染层和逻辑层运行。主要用于:
1. 在渲染层,提供各类组件来组建界面的元素
2. 在逻辑层,提供各类API来处理各种逻辑
3. 处理数据绑定、组件系统、事件系统、通信系统等一系列框架逻辑。

* 由于小程序的渲染层和逻辑层是两个线程管理,两个线程各自注入了基础库。小程序的基础库不会被打包在某个小程序的代码包里边,它会被提前内置在 微信客户端。
1. 降低业务小程序的代码包大小
2. 可以单独修复基础库中的BUG,无需修改业务小程序的代码包。

## 小程序的启动
### 小程序启动过程
* 初次进入小程序的时候,微信客户端初始化好宿主环境,同时从网络下载或者本地缓存中拿到小程序的代码包,把它注入到宿主环境。大概是这么个过程：
1. 创建线程(渲染层和逻辑层),启动小程序
2. 载入基础库(WebView基础库和AppService基础库)
3. 载入小程序业务代码(下载或者从本地缓存中拿到)。
4. 使用App()注册程序实例。

## 获取App实例
* App的生命周期是由微信客户端根据用户操作主动触发的。故我们通过getApp()获取实例之后,不应该私自调用生命周期函数。`具体的原理是,小程序的JS脚本是运行在JsCore的线程里,小程的每个页面各自有一个WebView线程进行渲染,所以小程序切换页面时,小程序逻辑层的JS脚本运行上下文依旧在同一个JsCore线程中。` 因此，App 构造器可以传递其他参数作为全局属性以达到全局共享数据的目的。
* 由于所有页面的脚本逻辑都跑在同一个JsCore线程,页面使用setTimeout或者setInterval的定时器,即使切换了页面,也需要自行清理定时器。可以选择：
1. 在页面离开的 onUnload、onHide等时候自行处理
2. 做全局的定时器管理(当然也还是需要关闭时清理)