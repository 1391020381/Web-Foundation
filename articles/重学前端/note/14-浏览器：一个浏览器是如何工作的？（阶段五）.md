* 把url变成字符流,把字符流变成词(token)流,把词(token)流构造成DOM树,把不含样式信息的DOM树应用CSS规则,变成包含样式信息的DOM树,并且根据样式信息,计算了每个元素的位置和大小。

## 渲染
* 本文中的渲染统一指的是它在图形学的意义,也就是把模型变成位图的过程。
* 这里的位图就是在内存里建立一张二维表格,把一张图片的每个像素对应的颜色保存进去(位图信息也是DOM树中占据浏览器内存最多的信息。我们做内存占用优化时,主要就是考虑这一部分)
* 浏览器中渲染这个过程，就是把每一个元素对应的盒变成位图。这里的元素包括 HTML 元素和伪元素，一个元素可能对应多个盒（比如 inline 元素，可能会分成多行）。每一个盒对应着一张位图。


* 这个渲染过程是非常复杂的，但是总体来说，可以分成两个大类：图形和文字。
* 一般的操作系统会提供一个底层库，比如在 Android 中，有大名鼎鼎的 Skia，而 Windows 平台则有 GDI，一般的浏览器会做一个兼容层来处理掉平台差异。
* 盒中的文字，也需要用底层库来支持，叫做字体库。字体库提供读取字体文件的基本能力，它能根据字符的码点抽取出字形。
* 字形分为像素字形和矢量字形两种。通常的字体，会在 6px 8px 等小尺寸提供像素字形，比较大的尺寸则提供矢量字形。矢量字形本身就需要经过渲染才能继续渲染到元素的位图上去。目前最常用的字体库是 Freetype，这是一个 C++ 编写的开源的字体库。

## 合成(compositing)
* 这个过程实际上是一个性能考量,它并非实现浏览器的必要一环
* 渲染过程不会把子元素渲染到位图上面,合成的过程,就是为一些元素创建一个 "合成后的位图"(我们把它称为合成层),把一部分子元素渲染到合成大位图上面。

### 合成策略
* 目前，主流浏览器一般根据 position、transform 等属性来决定合成策略，来“猜测”这些元素未来可能发生变化。
* will-change

## 绘制
* 绘制是把“位图最终绘制到屏幕上，变成肉眼可见的图像”的过程，不过，一般来说，浏览器并不需要用代码来处理这个过程，浏览器只需要把最终要显示的位图交给操作系统即可。
* 我们把任何位图合成到这个最终位图 的操作称为绘制。
*  计算机图形学中，我们使用的方案就是“脏矩形”算法，也就是把屏幕均匀地分成若干矩形区域。



* canvas模拟一个iframe