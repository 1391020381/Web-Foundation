# CommonJS规范
## CommonJS对模块的定义十分简单,主要分为模块引用、模块定义和模块标识3个部分
1. 模块引用
* require()方法,这个方法接受模块标识,以此引入一个模块的api到当前上下文。
2. 模块定义
* 在模块中,上下文提供require()方法来引入外部模块。对应引入的功能,上下文提供了 exports对象用于导出当前模块的方法或者变量,并且它是唯一导出的出口。在模块中,还存在一个moule对象,它代表模块自身,而exports是module的属性。在Node中,一个文件就是一个模块,将方法挂载到exports对象上作为属性即可定义导出。
3. 模块标识
* 模块标识其实就是传递给require()方法的参数,它必须是符合小驼峰命名的字符串,或者以...开头的相对路径,或者绝对路径。它可以没有文件名后缀.js
# Node的模块实现
* 在Node中引入模块,需要经历如下3个步骤
1. 路径分析
2. 文件定位
3. 编译执行
* 在Node中模块分为两类:一类是Node提供的模块,称为核心模块；另外是用户编写的模块，称为文件模块。
* 核心模块部分在Node源代码的编译过程中,编译进了二进制执行文件。在Node进程启动时,部分核心模块就被直接加载进内存中，所以这部分核心模块引入使,文件定位和编译执行这两个步骤可以省略掉,并且在路径分析中优先判断,所以它的加载速度是最快的。
* 文件模块则是运行是动态加载,需要完整的路径分析、文件定位、编译执行过程,速度比核心模块慢。

# 详细的模块加载过程
1. 优先从缓存加载
* 与前端浏览器会缓存静态脚本文件提高性能一样,Node对引入过的模块都会进行缓存,以减少二次引入时的开销。不同的地方在于,浏览器仅仅缓存文件,而Node缓存的是编译和执行之后的对象。
* 不论是核心模块还是文件模块,require()方法对相同模块的二次加载都一律采用缓存优先的方式,这是`第一优先级`的不同之区在于核心模块的缓存检查先与文件模块的缓存检查。
2. 路径分析和文件定位
    * `模块路径 module.paths`
* 当前文件目录下的node_modules目录
* 父目录下的node_modules目录
* 父目录下的父目录下的node_modules目录
* 沿路径向上逐级递归,直到根目录下的node_modlues目录
* 从缓存加载的优化策略使得二次引入时不需要路径分析、文件定位和编译执行的过程,大大提高了再次加载模块时的效率。
* 文件扩展名分析,当不包含文件扩展名,这种情况下，Node会按.js .node  .json的次序补足扩展名,依次尝试。 需要调用 fs模块同步阻塞式判断文件是否存在。
    * `目录分析和包`
* 在分析标识符的过程中,require()通过分析文件扩展名之后,可能没有查找对应文件,但是却得到一个目录,这在引入自定义目录和逐个目录路径进行查找时经常会出现,此时会将目录当做一个包来处理。
* 在这个过程中,Node对CommonJS包规范进行了一定程度的支持。首先,Node在当前目录下查找package.json(commonjs包规定定义的包描述文件)，通过JSON.parse()解析描述对象,从中取出main属性指定的文件名进行定位。如果文件名缺少扩展名,将会进入扩展名分析的步骤。而如果main属性指定的文件名错误,或者压根没有package.json文件,Node会将index当做默认文件名,然后依次查找Index.js index.node index.json.如果在目录分析的过程中没有定位成功任何文件，则自定义模块进入下一个模块路径进行查找。如果模块路径数组都被遍历完毕,依然没有查找大目标文件,则会抛出查找失败的异常
    * `模块编译`
 * 在Node中,每个文件模块都是一个对象 
 * 编译和执行是引入文件模块的最后一个阶段。定位到具体的文件后,Node会新建一个模块对象,然后根据路径载入并编译。对于不同的扩展名,其载入方式也有所不同，。
 1. .js文件。通过fs模块同步读取文件后编译执行。
 2. .node文件。这是用C/C++编写的扩展文件，通过dlopen()方法加载最后编译生成的文件。
 3. .json文件。通过fs模块同步读取文件后,用json.parse()解析返回结果
 4. 其余扩展名文件它们都被当做.js文件载入

 # 包与NPM
 * 前后端公用模块
 * AMD Asynchronous Module Definition 异步模块定义 AMD规范是CommonJS模块规范的一个延伸。
 * define(id?,dependencies?,factory)
