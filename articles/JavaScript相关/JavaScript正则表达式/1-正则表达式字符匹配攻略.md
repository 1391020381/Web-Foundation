# 两种模糊匹配
1. 横向模糊匹配
   * 横向模糊指的是,一个正则可匹配的字符串的长度不是固定的,可以使多种情况的。
   * 实现的方式使用量词.譬如 {m,n},表示连续出现最少m次,最多n次
   * 量词
   * {m,} 至少出现 m次
   * {m}  等价于{m,m},表示出现 m次
   * ？ {0,1} 表示出现或者不出现
   * + {1,}  至少一次
   *  * 任意次
2. 纵向模糊匹配
   * 纵向模糊指的是：一个正则匹配的字符串,具体到一位字符时,它可以不是某个确定的字符可以有多种可能。
   * 实现的方式是使用字符组。譬如[abc],表示该字符是可以字符 'a'、'b'、'c'中的任何一个   
   * 字符组
   * 表示范围[a-zA-Z] 
   * 在字符组只能匹配 - 要么放在开头,要么放在结尾,要么转义。总之不会让引擎认为是范围表示法就行了。
   * 排除字符组：字符组的第一位放 ^(脱字符)，表示求反的概念。
   * \d   [0-9]
   * \D   [^0-9]
   * \w   [0-9a-zA-Z_]
   * \W   [^0-9a-zA-Z_]
   * \s   
   * \S  
   * . 通配符,表示几乎任意字符
   * 贪婪匹配与惰性匹配
   * /\d{2,5}?/  虽然 2到 5次都行，当2个就够了的时候,就不再尝试了。
   * 多选分支  (p1|p2|p3)
   # 案例
   * 匹配字符,无非就是 字符组、量词和分支结构的组合使用
   * 分析正则的原则是，细分情况

   # 总结
   * [0-9a-zA-Z_]  [^0-9a-zA-Z]
   * {m,n}  {m} ? + * 
   * (p1|p2|p3)
   * . 任意匹配