## 面试技巧
* 准备要充分
* 知识要系统
* 沟通要简洁
* 内心要诚实
* 态度要谦虚
* 回答要灵活

1. 页面布局
    * 三栏布局
        * 左右宽度固定,中间自适应
        * 上下高度固定,中间自适应
    * 两栏布局
        * 左宽度固定,右自适应
        * 右宽度固定,左自适应
        * 上高度固定,下自适应
        * 下高度固定,上自适应    
2. CSS盒模型
* [CSS原理解析之模型篇](https://juejin.im/post/59dca82051882578db27b1d6)
    * 标准模型 + IE模型
    * 标准模型和IE模型区别
        * 标准模型的宽度和高度 是指 内容(content)的高度和宽度
        * IE模型  content + padding+border
    * CSS如何设置这两种模型
        * box-sizing:content-box; 标准
        * box-sizing:border-box; IE  
    * JS如设置和获取盒模型对应的高和宽
        * dom.style.width/height <内联,在标签上、通过style 和Link的方式无法获取>
        * dom.currentStyle.width/height
        * window.getComputedStyle(dom,null).width/height
        * dom.getBoundingClientRect().width/height/left/top
    * 实例题(边距重叠)
    * BFC
        * 基本概念
        * 原理
        * 创建
        * 使用场景
    * IFC
3. DOM事件<BOM>
    * 基本概念：DOM事件的级别
        * DOM0  element.onclick = function(){}
        * DOM2  element.addEventListener('click',function(){}{},false)   ie 不一样  attatch
        * DOM3  element.addEventListener('keyup',function(){},false)  默认false 冒泡
    * DOM事件的模型
        * 捕获
        * 冒泡
    * DOM事件流
        * 捕获  目标阶段  冒泡
    * 描述DOM事件捕获的具体流程
        * window -> document -> html<document.documentElement> ->body-> 目标元素 
    * Event对象的常见应用
        * event.preventDefault()  阻止默认事件
        * event.stopPropagation()
        * event.stopImmediatePropagation() 事件响应优先级
        * event.currentTarget 当前绑定事件的对象(父元素)
        * event.target 当前被点击的元素
    * 自定义事件
 ```
var eve = new Event('custome')
ev.addEventListener('custome',function(){  // ev  一个dom对象
    console.log('custome')
})
ev.dispatchEvent(eve)

```
* CustomEvent   
    * 与Event类似,但可以传参
4. HTTP 协议
    1. HTTP协议的主要特点
        * 无连接
            * 连接一次会断掉
        * 无状态
            * 无法区分 两次连接的状态
        * 简单快速
            * URI
        * 灵活
            * 通过Content-type 来传递不同的数据
    2. HTTP报文的组成部分
        1. 请求报文
            * 请求行
            * 请求头
            * 空行
            * 请求体
        2. 响应报文
            * 状态行
            * 响应头
            * 空行
            * 响应体    
    3. HTTP方法
        * GET  获取资源
        * POST 传输资源
        * PUT  更新资源
        * DELETE 删除资源
        * HEAD  获取报文首部
    4. POST和GET的区别
        * `GET在浏览器回退时是无害的,而POST会再次提交请求`
        * GET产生的URL地址可以被收藏,而POST不可以
        * `GET请求会被主动缓存,而POST不会,除非手动设置`
        * GET请求只能进行URL编码,而Post支持多种编码方式
        * `GET请求参数会被完整保留在浏览器历史记录里,而POST中的参数不会被保留`
        * `GET请求参数在URL中传参是有长度限制的,而POST没有限制  2kb`
        * 对参数的数据类型,GET只接受ASCII字符,而POST没有限制
        * GET比POST更不安全,因为参数直接暴露在URL上,所以不能用来传递敏感信息
        * `GET参数通过URL传递.post放在Requrest body中`
    5. HTTP状态码
        1. 1xx 指示信息  表示请求已接受,继续处理
        2. 2xx  
        3. 3xx
        4. 4xx
        5. 5xx
    6. 什么是持久连接
    * HTTP协议采用"请求-应答"模式,当使用普通模式,即非Keep-Alive模式时,每个请求/应答客户和服务端都要重新建一个连接,完成之后立即断开连接(HTTP协议为无连接的协议)
    * 当使用Keep-Alive模式(又称为持久连接、连接重用)时，Keep-Alive功能是客户端到服务端的连接持久有效，当出现对服务器的后继请求时,Keep-Alive功能避免了建立或者重新建立连接
    7. 什么是管线化
    * 在使用持久连接的情况下,某个连接上消息的传递类似于 请求1 -> 响应1 -> 请求2 ->响应2 ->  请求3 ->响应3
    * 某个连接上的消息变成类似这样   请求1 -> 请求2 -> 请求3 -> 响应1 ->响应2 ->响应3
    * 管线化是在 持久连接的情况下, 把请求一次打包,发送给后台,再一次返回。
    1. `管线化机制通过持久连接完成,仅HTTP/1.1支持此技术`
    2. `只有GET和HEAD请求可以进行管线化,而POST则有所限制`
    3. `初次创建连接时不应启动管线机制,因为对方(服务器)不一定支持HTTP/1.1版本协议`
    4. 管线化不会影响响应到来的顺序,如上面的例子所示,响应返回的顺序并未改变
    5. HTTP /1.1要求服务器端支持管线化,但并不要求服务端也对响应进行管线化处理,只是
    要求对于管线化的请求不失败即可
    6. 由于上面提到的服务端问题,开启管线化很可能并不会带来大幅度的性能提升,而且很多服务器端和代理程序对管线化的支持并不好,因此现代浏览器如Chrome和Firefox默认并未开启管线化支持。
5. 原型链
    1. 创建对象有几种方法
        ```
        var o1 = {name:'o1'}
        var o11 = new Object({name:"o11"})

        var M  = function(){this.name = 'o2'}
        var o2 = new M()

        var P = {name:'o3'}
        var o3 =  Object.create(P)
        ```
    2. 原型、构造函数、实例、原型链
    ![](https://raw.githubusercontent.com/1391020381/Web-Foundation/master/articles/%E8%B7%B3%E6%A7%BD%E9%9D%A2%E8%AF%95%E5%BF%85%E5%A4%87%E6%8A%80%E5%B7%A7/img/%E5%8E%9F%E5%9E%8B%E9%93%BE.png)
    3. instanceof的原理
     * instanceof运算符用来测试一个对象在其原型链中是否存在一个构造函数的prototype属性   
     * 其实是判断实例的__proto__指向是否和构造函数的prototype的指向的在一个原型链上 <在同一个原型链上都会判断为true>
     * 判断一个实例的原型的 constructor是否是否指向构造函数
    4. new 运算符 new Foo(...)
    1. 一个继承自Foo.prototype的新对象被创建
    2. 使用指定的参数调用构造函数Foo,并将this绑定到新创建的对象。new Foo等同于new Foo(),也就是没有指定参数列表,Foo不带任何参数调用的情况
    3. 由构造函数返回的对象就是new 表达式的结果。如果构造函数没有显示返回一个对象,则使用步骤1创建的对象。(一般情况下,构造函数不返回值,但是用户可以选择主动返回对象,来覆盖正常的对象创建步骤)
6. 面向对象
7. 通信
8. 安全
9. 算法