#  DRY
 *  Don’t Repeat Yourself
# 理解发现解决方案的过程比解决方案本身更有用。


* 在绝大多数情况下，你都可以同时使用各种不同的语法,并且通过层叠机制来确保哪条声明最终生效。出于这个原因,你应该把标准语法排在最后。
# 提供回退机制
* 添加实色的一个好方法是取渐变色的平均值。
```
background: rgb(255, 128, 0);
background: -moz-linear-gradient(0deg, yellow, red);
background: -o-linear-gradient(0deg, yellow, red);
background: -webkit-linear-gradient(0deg, yellow, red);
background: linear-gradient(90deg, yellow, red);
```
* [ Modernizr](http://modernizr.com/) 给根元素添加一些辅助类。
```
h1{color:gray}
.textshadow h1{
color: transparent;
text-shadow: 0 0 .3em gray;
}
```
* 也可以自己
写一小段 JavaScript 代码来实现相同的功能——做一些特性检测然后给根元
素加一些辅助类。如果要检测某个样式属性是否被支持，核心思路就是在任一元素的 element.style 对象上检查该属性是否存在
* 如果要检测选择符和 @ 规则的支持情况，则会稍稍复杂一些。不过原
理也很简单，在解析 CSS 代码时，浏览器总会丢弃它自己无法识别的部分，
因此我们可以动态地应用样式并检查它是否生效，以此来判断浏览器是否可
以识别某个特性。当然，我们也要清楚地认识到，浏览器可以解析某个 CSS
特性并不代表它已经实现（或正确实现）了这个特性。


# CSS编码技巧
1. 尽量减少代码重复
2. currentColor
3. inherit
4. 相信你的眼睛，而不是数字
5. 关于响应式网页设计
    * 媒体查询不能以一种连续的方式来修复问题。它们的工作原理基于某几个特定的阶梯(亦称 断点)，如果大部分样式代码并不是以弹性的方式来编写的,那么媒体查询能做的只是修补某个特定分辨率下的特定问题——这本质上只是把灰尘扫到地毯下面而已。
    * 媒体查询的断点不应该有具体的设备来决定,而应该根据设计自身来决定。这不仅是因为我们的网站需要面向的
    设备太多了(尤其是考虑到未来的设备)，还因为一个网站在桌面端可能会以任意尺寸的窗口来显示。如果你有信心自己的设计在任何可能出现的视口尺寸下都能良好工作，谁关心这些设备的分辨率具体是多少呢？。
    * 总的来说，我们的思路是尽最大努力实现弹性可伸缩的布局，并在媒体
查询的各个断点区间内指定相应的尺寸。当网页本身的设计足够灵活时，让
它变成响应式应该只需要用到一些简短的媒体查询代码。

# 合理使用简写